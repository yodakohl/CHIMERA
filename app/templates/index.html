<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Satellite Infrastructure Scanner</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header>
      <h1>Satellite Infrastructure Scanner</h1>
      <p>
        Upload high-resolution satellite imagery and let the system look for unusual
        infrastructure. The analyzer combines image captioning, open-ended visual question
        answering, and general-purpose object detection to surface noteworthy findings.
      </p>
    </header>

    {% if message %}
    <div class="flash">{{ message }}</div>
    {% endif %}

    <section class="upload">
      <details class="upload-toggle">
        <summary>
          <div class="summary-content">
            <span class="summary-title">Analyze a single image</span>
            <span class="summary-description"
              >Upload an individual scene when you don't need a full area
              scan.</span
            >
          </div>
        </summary>
        <form class="form-card" action="/analyze" method="post" enctype="multipart/form-data">
          <label for="image">Satellite image</label>
          <input id="image" name="image" type="file" accept="image/*" required />

          <label for="prompt">Analysis prompt</label>
          <textarea id="prompt" name="prompt" rows="3">{{ default_prompt }}</textarea>

          <button type="submit">Analyze image</button>
        </form>
      </details>
    </section>

    <section class="area">
      <h2>Automatic area scan</h2>
      <p>
        Request imagery for a latitude/longitude bounding box and the scanner will automatically
        download tiles from the selected provider before running the analysis pipeline on each tile.
        MapTiler's global satellite basemap is the default for crisp worldwide coverage, with NASA's
        GIBS mosaics and the USGS NAIP aerial program available as alternatives when desired.
      </p>
      <form class="form-card" id="area-scan-form" action="/scan-area" method="post">
        <div class="form-grid">
          <div class="field">
            <label for="north">North latitude</label>
            <input
              id="north"
              name="north"
              type="number"
              step="0.0001"
              min="-90"
              max="90"
              value="{{ '%.4f'|format(default_bounds.north) }}"
              required
            />
          </div>
          <div class="field">
            <label for="south">South latitude</label>
            <input
              id="south"
              name="south"
              type="number"
              step="0.0001"
              min="-90"
              max="90"
              value="{{ '%.4f'|format(default_bounds.south) }}"
              required
            />
          </div>
          <div class="field">
            <label for="west">West longitude</label>
            <input
              id="west"
              name="west"
              type="number"
              step="0.0001"
              min="-180"
              max="180"
              value="{{ '%.4f'|format(default_bounds.west) }}"
              required
            />
          </div>
          <div class="field">
            <label for="east">East longitude</label>
            <input
              id="east"
              name="east"
              type="number"
              step="0.0001"
              min="-180"
              max="180"
              value="{{ '%.4f'|format(default_bounds.east) }}"
              required
            />
          </div>
          <div class="field field-full map-field">
            <span class="field-label">Select scan area</span>
            <div id="scan-map" class="scan-map" aria-describedby="map-hint"></div>
            <p class="hint" id="map-hint">
              Drag the corner handles to adjust the bounding box or edit the
              coordinates directly.
            </p>
          </div>
          <div class="field">
            <label for="tile-size">Tile size (degrees)</label>
            <input
              id="tile-size"
              name="tile_size"
              type="number"
              step="0.01"
              min="{{ '%.2f'|format(min_tile_size) }}"
              max="{{ '%.2f'|format(max_tile_size) }}"
              value="{{ '%.2f'|format(default_tile_size) }}"
              required
            />
          </div>
          <div class="field">
            <label for="provider">Imagery source</label>
            <select id="provider" name="provider">
              {% for option in providers %}
              <option
                value="{{ option.key }}"
                title="{{ option.description }}"
                {% if option.key == selected_provider %}selected{% endif %}
              >
                {{ option.label }}
              </option>
              {% endfor %}
            </select>
            <p class="hint">Hover the options for coverage and resolution details.</p>
          </div>
          <div class="field">
            <label for="date">Acquisition date (optional)</label>
            <input
              id="date"
              name="date"
              type="date"
              {% if default_date %}value="{{ default_date }}"{% endif %}
            />
          </div>
        </div>
        <div class="form-actions">
          <button type="button" id="global-scan" class="secondary-button">
            Use worldwide coverage
          </button>
          <span class="hint">
            Prefills the form with global bounds and the largest supported tile size.
          </span>
        </div>
        <p class="hint">
          Large areas may require increasing the tile size to keep the number of imagery requests
          and download time manageable.
        </p>

        <label for="area-prompt">Analysis prompt</label>
        <textarea id="area-prompt" name="prompt" rows="3">{{ default_prompt }}</textarea>

        <div class="form-actions">
          <button type="submit" id="start-scan">Scan area</button>
          <button type="button" id="stop-scan" class="danger-button" disabled>
            Stop scan
          </button>
        </div>
      </form>
      <details class="scan-progress" id="scan-progress">
        <summary>
          <div class="summary-content">
            <span class="summary-title">Live scan progress</span>
            <span class="summary-description"
              >Updates appear as each tile is downloaded and analyzed.</span
            >
          </div>
        </summary>
        <div class="scan-progress-body">
          <ul id="scan-events" class="scan-events"></ul>
        </div>
      </details>
      <div class="scan-gallery" id="scan-gallery">
        <div class="scan-gallery-header">
          <h3>Scanned tile thumbnails</h3>
          <div class="scan-gallery-actions">
            <button type="button" id="reclassify-tiles" class="button button-secondary" disabled>
              Reclassify cached tiles
            </button>
          </div>
        </div>
        <p class="hint">
          Preview the most recent imagery tiles analyzed during the current scan.
        </p>
        <div class="thumbnail-grid" id="scan-thumbnails"></div>
      </div>
    </section>

    <section class="usage results">
      <h2>API usage</h2>
      {% if api_usage %}
      <table>
        <thead>
          <tr>
            <th>Provider</th>
            <th>Requests</th>
            <th>Last used</th>
          </tr>
        </thead>
        <tbody>
          {% for entry in api_usage %}
          <tr>
            <td>{{ entry.provider_label }}</td>
            <td>{{ entry.request_count }}</td>
            <td>
              {% if entry.last_used_at %}
              {{ entry.last_used_at.strftime('%Y-%m-%d %H:%M:%S') }}
              {% else %}
              &mdash;
              {% endif %}
            </td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
      {% else %}
      <p>No API requests have been recorded yet.</p>
      {% endif %}
    </section>

    <section class="results">
      <div class="results-header">
        <h2>Analysis history</h2>
        <div class="results-actions">
          <button
            type="button"
            id="clear-history"
            class="button button-danger"
            {% if not results %}disabled{% endif %}
          >
            Clear history
          </button>
        </div>
      </div>
      <p
        class="hint"
        id="history-empty-message"
        {% if results %}hidden{% endif %}
      >
        No analyses have been recorded yet. Upload your first satellite scene to begin.
      </p>
      <div
        id="history-table-wrapper"
        class="history-table-wrapper"
        {% if not results %}hidden{% endif %}
      >
        <table>
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Image</th>
              <th>Caption</th>
              <th>Unusual findings</th>
              <th>Detected objects</th>
            </tr>
          </thead>
          <tbody id="analysis-history-body">
            {% for result in results %}
            <tr>
              <td>{{ result.created_at.strftime('%Y-%m-%d %H:%M:%S') }}</td>
              <td class="image-cell">
                {% if result.image_filename %}
                {% set image_url = '/data/uploads/' ~ result.image_filename %}
                {% set image_label = result.image_filename.rsplit('/', 1)[-1] %}
                <a href="{{ image_url }}" target="_blank" class="image-link">
                  <img
                    src="{{ image_url }}"
                    alt="{{ image_label }}"
                    class="tile-thumbnail"
                    loading="lazy"
                  />
                  <span>{{ image_label }}</span>
                </a>
                {% else %}
                <em>No image available</em>
                {% endif %}
              </td>
              <td>{{ result.caption }}</td>
              <td>{{ result.unusual_summary }}</td>
              <td>
                {% if result.detections %}
                <ul>
                  {% for detection in result.detections %}
                  <li>
                    <strong>{{ detection["object"] }}</strong>
                    (confidence {{ '%.2f'|format(detection["confidence"]) }})
                    {% set answers = detection.get('answers') %}
                    {% if answers %}
                    <div class="meta">Model answers: {{ answers|join(', ') }}</div>
                    {% endif %}
                    {% set box = detection.get('box') %}
                    {% if box %}
                    <div class="meta">
                      Bounding box: xmin {{ box["xmin"] }}, ymin {{ box["ymin"] }}, xmax
                      {{ box["xmax"] }}, ymax {{ box["ymax"] }}
                    </div>
                    {% endif %}
                  </li>
                  {% endfor %}
                </ul>
                {% else %}
                <em>No objects detected above the confidence threshold</em>
                {% endif %}
              </td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </section>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      (function () {
        const defaultPrompt = {{ default_prompt|tojson }};
        const form = document.getElementById("area-scan-form");
        const startButton = document.getElementById("start-scan");
        const stopButton = document.getElementById("stop-scan");
        const globalButton = document.getElementById("global-scan");
        const eventsList = document.getElementById("scan-events");
        const progressSection = document.getElementById("scan-progress");
        const gallerySection = document.getElementById("scan-gallery");
        const thumbnailGrid = document.getElementById("scan-thumbnails");
        const reclassifyButton = document.getElementById("reclassify-tiles");
        const clearHistoryButton = document.getElementById("clear-history");
        const historyTable = document.getElementById("analysis-history-body");
        const historyContainer = document.getElementById("history-table-wrapper");
        const historyEmptyMessage = document.getElementById("history-empty-message");
        const boundsInputs = {
          north: document.getElementById("north"),
          south: document.getElementById("south"),
          east: document.getElementById("east"),
          west: document.getElementById("west"),
        };

        let refreshBoundsFromInputs = () => {};
        let eventSource = null;
        let activeScanId = null;
        let tileCounter = 0;
        let scanFootprintsLayer = null;
        let reclassifying = false;
        let scanRunning = false;

        const tileCache = new Map();

        function updateHistoryVisibility() {
          if (!historyTable) return;
          const hasRows = historyTable.childElementCount > 0;
          if (historyContainer) {
            historyContainer.hidden = !hasRows;
          }
          if (historyEmptyMessage) {
            historyEmptyMessage.hidden = hasRows;
          }
          if (clearHistoryButton) {
            clearHistoryButton.disabled = !hasRows;
          }
        }

        function updateReclassifyState() {
          if (!reclassifyButton) return;
          const hasTiles = tileCache.size > 0;
          reclassifyButton.disabled = !hasTiles || reclassifying || scanRunning;
        }

        function cacheTile(tile) {
          if (!tile || !tile.image) {
            return null;
          }
          const existing = tileCache.get(tile.image) || {};
          const merged = { ...existing, ...tile };
          tileCache.set(tile.image, merged);
          updateReclassifyState();
          return merged;
        }

        updateHistoryVisibility();
        updateReclassifyState();

        function getBoundsFromInputs() {
          if (!window.L || typeof window.L.latLngBounds !== "function") {
            return null;
          }
          const north = boundsInputs.north ? parseFloat(boundsInputs.north.value) : NaN;
          const south = boundsInputs.south ? parseFloat(boundsInputs.south.value) : NaN;
          const east = boundsInputs.east ? parseFloat(boundsInputs.east.value) : NaN;
          const west = boundsInputs.west ? parseFloat(boundsInputs.west.value) : NaN;
          if ([north, south, east, west].some((value) => Number.isNaN(value))) {
            return null;
          }
          const normalizedNorth = Math.max(north, south);
          const normalizedSouth = Math.min(north, south);
          const normalizedEast = Math.max(east, west);
          const normalizedWest = Math.min(east, west);
          return L.latLngBounds(
            [
              [normalizedSouth, normalizedWest],
              [normalizedNorth, normalizedEast],
            ]
          );
        }

        initializeMap();

        function safeParse(data) {
          try {
            return JSON.parse(data);
          } catch (error) {
            return null;
          }
        }

        function resetEvents() {
          tileCounter = 0;
          if (eventsList) {
            eventsList.innerHTML = "";
          }
          if (progressSection) {
            progressSection.classList.remove("visible");
            progressSection.open = false;
          }
          if (thumbnailGrid) {
            thumbnailGrid.innerHTML = "";
          }
          if (gallerySection) {
            gallerySection.classList.remove("visible");
          }
          tileCache.clear();
          updateReclassifyState();
          clearScanFootprints();
        }

        function appendEvent(message, type = "info") {
          if (!eventsList) return;
          const item = document.createElement("li");
          item.className = `event-${type}`;

          const time = document.createElement("span");
          time.className = "event-time";
          time.textContent = new Date().toLocaleTimeString();

          const text = document.createElement("span");
          text.className = "event-message";
          text.textContent = message;

          item.appendChild(time);
          item.appendChild(text);
          eventsList.prepend(item);
          if (progressSection) {
            const wasHidden = !progressSection.classList.contains("visible");
            progressSection.classList.add("visible");
            if (wasHidden) {
              progressSection.open = true;
            }
          }
        }

        function getFileNameFromPath(path) {
          if (typeof path !== "string") return "";
          const parts = path.split("/").filter(Boolean);
          return parts.length ? parts[parts.length - 1] : path;
        }

        function addThumbnail(tile) {
          if (!thumbnailGrid || !tile || !tile.image) {
            return;
          }
          const link = document.createElement("a");
          link.href = tile.image;
          link.target = "_blank";
          link.className = "scan-thumbnail";

          const img = document.createElement("img");
          img.src = tile.image;
          img.alt = tile.caption || getFileNameFromPath(tile.image) || "Tile";
          img.loading = "lazy";

          link.appendChild(img);
          thumbnailGrid.prepend(link);

          while (thumbnailGrid.childElementCount > 12) {
            thumbnailGrid.removeChild(thumbnailGrid.lastElementChild);
          }

          if (gallerySection) {
            gallerySection.classList.add("visible");
          }
        }

        function clearScanFootprints() {
          if (scanFootprintsLayer) {
            scanFootprintsLayer.clearLayers();
          }
        }

        function highlightTileOnMap(tile, status = "success") {
          if (!scanFootprintsLayer || !tile || !tile.bounds) {
            return;
          }

          const { bounds } = tile;
          const south = Number.parseFloat(bounds.south);
          const west = Number.parseFloat(bounds.west);
          const north = Number.parseFloat(bounds.north);
          const east = Number.parseFloat(bounds.east);
          if ([south, west, north, east].some((value) => Number.isNaN(value))) {
            return;
          }

          const styles = {
            success: {
              color: "#38bdf8",
              weight: 1,
              fillOpacity: 0.1,
              dashArray: "4 4",
              interactive: false,
            },
            warning: {
              color: "#facc15",
              weight: 1,
              fillOpacity: 0.12,
              dashArray: "4 6",
              interactive: false,
            },
            error: {
              color: "#f97316",
              weight: 1.2,
              fillOpacity: 0.18,
              dashArray: "2 6",
              interactive: false,
            },
          };

          const style = styles[status] || styles.success;

          L.rectangle(
            [
              [south, west],
              [north, east],
            ],
            style
          ).addTo(scanFootprintsLayer);
        }

        function setRunning(running) {
          scanRunning = running;
          if (startButton) startButton.disabled = running;
          if (stopButton) stopButton.disabled = !running;
          if (!running) {
            activeScanId = null;
          }
          updateReclassifyState();
        }

        function closeSource() {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        }

        function updateHistoryTable(tile) {
          if (!historyTable || !tile) return;
          const row = document.createElement("tr");

          const timestampCell = document.createElement("td");
          const timestamp = tile.timestamp ? new Date(tile.timestamp) : new Date();
          timestampCell.textContent = timestamp.toLocaleString();
          row.appendChild(timestampCell);

          const imageCell = document.createElement("td");
          imageCell.className = "image-cell";
          if (tile.image) {
            const link = document.createElement("a");
            link.href = tile.image;
            link.target = "_blank";
            link.className = "image-link";

            const thumbnail = document.createElement("img");
            thumbnail.src = tile.image;
            thumbnail.alt = getFileNameFromPath(tile.image) || "Tile";
            thumbnail.className = "tile-thumbnail";
            thumbnail.loading = "lazy";

            const label = document.createElement("span");
            label.textContent = getFileNameFromPath(tile.image) || "Tile";

            link.appendChild(thumbnail);
            link.appendChild(label);
            imageCell.appendChild(link);
          } else {
            imageCell.textContent = "Tile";
          }
          row.appendChild(imageCell);

          const captionCell = document.createElement("td");
          captionCell.textContent = tile.caption || "";
          row.appendChild(captionCell);

          const unusualCell = document.createElement("td");
          unusualCell.textContent = tile.unusual_summary || "";
          row.appendChild(unusualCell);

          const detectionsCell = document.createElement("td");
          if (Array.isArray(tile.detections) && tile.detections.length) {
            const list = document.createElement("ul");
            tile.detections.forEach((item) => {
              if (!item) return;
              const entry = document.createElement("li");
              const strong = document.createElement("strong");
              strong.textContent = item.object || "Object";
              entry.appendChild(strong);
              if (typeof item.confidence === "number") {
                const confidenceText = document.createTextNode(
                  ` (confidence ${item.confidence.toFixed(2)})`
                );
                entry.appendChild(confidenceText);
              }
              const answers = Array.isArray(item.answers)
                ? item.answers.filter(Boolean)
                : null;
              if (answers && answers.length) {
                const answersMeta = document.createElement("div");
                answersMeta.className = "meta";
                answersMeta.textContent = `Model answers: ${answers.join(", ")}`;
                entry.appendChild(answersMeta);
              }
              const box = item.box;
              if (box && typeof box === "object") {
                const boxMeta = document.createElement("div");
                boxMeta.className = "meta";
                boxMeta.textContent = `Bounding box: xmin ${box.xmin}, ymin ${box.ymin}, xmax ${box.xmax}, ymax ${box.ymax}`;
                entry.appendChild(boxMeta);
              }
              list.appendChild(entry);
            });
            detectionsCell.appendChild(list);
          } else {
            const empty = document.createElement("em");
            empty.textContent = "No objects detected above the confidence threshold";
            detectionsCell.appendChild(empty);
          }
          row.appendChild(detectionsCell);

          historyTable.prepend(row);
          updateHistoryVisibility();
        }

        if (globalButton) {
          globalButton.addEventListener("click", function () {
            const north = document.getElementById("north");
            const south = document.getElementById("south");
            const east = document.getElementById("east");
            const west = document.getElementById("west");
            const tile = document.getElementById("tile-size");
            if (north) north.value = "90";
            if (south) south.value = "-90";
            if (east) east.value = "180";
            if (west) west.value = "-180";
            if (tile) tile.value = "{{ '%.2f'|format(max_tile_size) }}";
            if (typeof refreshBoundsFromInputs === "function") {
              refreshBoundsFromInputs();
            }
          });
        }

        if (form) {
          form.addEventListener("submit", function (event) {
            event.preventDefault();
            if (eventSource) return;

            const formData = new FormData(form);
            const params = new URLSearchParams();
            formData.forEach((value, key) => {
              if (typeof value === "string") {
                params.append(key, value);
              }
            });

            activeScanId =
              window.crypto && typeof window.crypto.randomUUID === "function"
                ? window.crypto.randomUUID()
                : `scan-${Date.now()}`;
            params.append("scan_id", activeScanId);

            const url = `/scan-area/stream?${params.toString()}`;
            resetEvents();
            appendEvent("Starting scan...", "info");
            setRunning(true);

            eventSource = new EventSource(url);

            eventSource.addEventListener("status", (evt) => {
              const payload = safeParse(evt.data);
              if (payload && payload.message) {
                appendEvent(payload.message, "info");
              }
            });

            eventSource.addEventListener("tile", (evt) => {
              const payload = safeParse(evt.data);
              if (!payload) return;
              const index =
                typeof payload.index === "number" ? payload.index : tileCounter + 1;
              tileCounter = index;
              const caption = payload.caption || "Tile analyzed.";
              appendEvent(`Tile #${index}: ${caption}`, "success");
              cacheTile(payload);
              updateHistoryTable(payload);
              addThumbnail(payload);
              const tileStatus = payload.low_detail ? "warning" : "success";
              highlightTileOnMap(payload, tileStatus);
            });

            eventSource.addEventListener("download-failed", (evt) => {
              const payload = safeParse(evt.data);
              if (payload && payload.message) {
                appendEvent(payload.message, "warning");
              }
            });

            eventSource.addEventListener("analysis-failed", (evt) => {
              const payload = safeParse(evt.data);
              if (payload && payload.message) {
                appendEvent(payload.message, "warning");
              }
              highlightTileOnMap(payload, "error");
            });

            eventSource.addEventListener("complete", (evt) => {
              const payload = safeParse(evt.data);
              if (payload && payload.message) {
                appendEvent(payload.message, "success");
              } else {
                appendEvent("Area scan completed.", "success");
              }
              setRunning(false);
              closeSource();
            });

            eventSource.addEventListener("cancelled", (evt) => {
              const payload = safeParse(evt.data);
              appendEvent((payload && payload.message) || "Scan cancelled.", "warning");
              setRunning(false);
              closeSource();
            });

            eventSource.addEventListener("error", (evt) => {
              const payload = safeParse(evt.data);
              appendEvent((payload && payload.message) || "Scan failed.", "error");
              setRunning(false);
              closeSource();
            });

            eventSource.onerror = function () {
              appendEvent("Connection to the scanner was interrupted.", "error");
              setRunning(false);
              closeSource();
            };
          });
        }

        if (stopButton) {
          stopButton.addEventListener("click", function () {
            if (!activeScanId) return;
            fetch("/scan-area/stop", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ scan_id: activeScanId }),
            }).catch(() => {});
            appendEvent("Stop requested.", "info");
            setRunning(false);
            closeSource();
          });
        }

        if (reclassifyButton) {
          reclassifyButton.addEventListener("click", function () {
            if (reclassifyButton.disabled || tileCache.size === 0 || reclassifying) {
              return;
            }

            const promptInput = document.getElementById("area-prompt");
            const promptValue = promptInput ? promptInput.value : "";
            const prompt = (promptValue || "").trim() || defaultPrompt;

            const tiles = Array.from(tileCache.values()).map((tile) => ({
              image: tile.image,
              lat: tile.lat ?? null,
              lon: tile.lon ?? null,
              bounds: tile.bounds || null,
              degree_size: tile.degree_size ?? null,
              provider_label: tile.provider_label ?? null,
            }));

            if (!tiles.length) {
              return;
            }

            reclassifying = true;
            updateReclassifyState();
            appendEvent(
              `Reclassifying ${tiles.length} cached tile${tiles.length === 1 ? "" : "s"}...`,
              "info"
            );

            fetch("/scan-area/reclassify", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ prompt, tiles }),
            })
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Request failed");
                }
                return response.json();
              })
              .then((data) => {
                const results = Array.isArray(data.results) ? data.results : [];
                const errors = Array.isArray(data.errors) ? data.errors : [];
                let processed = typeof data.processed === "number" ? data.processed : results.length;

                results.forEach((result) => {
                  cacheTile(result);
                  updateHistoryTable(result);
                  const message = result.caption
                    ? `Reclassified tile: ${result.caption}`
                    : "Reclassified cached tile.";
                  appendEvent(message, "success");
                });

                errors.forEach((error) => {
                  const message =
                    error && error.message
                      ? error.message
                      : "Failed to reclassify a cached tile.";
                  appendEvent(message, "warning");
                });

                if (processed && results.length === 0 && errors.length === 0) {
                  appendEvent(
                    `Reclassified ${processed} cached tile${processed === 1 ? "" : "s"}.`,
                    "success"
                  );
                } else if (processed) {
                  appendEvent(
                    `Reclassification completed for ${processed} cached tile${processed === 1 ? "" : "s"}.`,
                    "info"
                  );
                } else if (!errors.length) {
                  appendEvent("No cached tiles were reclassified.", "warning");
                }
              })
              .catch(() => {
                appendEvent("Reclassifying cached tiles failed.", "error");
              })
              .finally(() => {
                reclassifying = false;
                updateReclassifyState();
              });
          });
        }

        if (clearHistoryButton) {
          clearHistoryButton.addEventListener("click", function () {
            if (clearHistoryButton.disabled) {
              return;
            }
            const confirmed = window.confirm(
              "This will remove all saved analysis results. Continue?"
            );
            if (!confirmed) {
              updateHistoryVisibility();
              return;
            }

            clearHistoryButton.disabled = true;

            fetch("/analysis/clear", { method: "POST" })
              .then((response) => {
                if (!response.ok) {
                  throw new Error("Request failed");
                }
                return response.json();
              })
              .then((data) => {
                if (historyTable) {
                  historyTable.innerHTML = "";
                }
                updateHistoryVisibility();
                const cleared = data && typeof data.cleared === "number" ? data.cleared : 0;
                const summary = cleared
                  ? `Cleared ${cleared} analysis entr${cleared === 1 ? "y" : "ies"}.`
                  : "Analysis history cleared.";
                appendEvent(summary, "info");
              })
              .catch(() => {
                appendEvent("Failed to clear analysis history.", "error");
              })
              .finally(() => {
                updateHistoryVisibility();
              });
          });
        }

        function initializeMap() {
          const container = document.getElementById("scan-map");
          if (!container || !window.L || typeof window.L.map !== "function") {
            return;
          }

          const map = L.map(container, {
            zoomControl: true,
            attributionControl: true,
          });
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "Â© OpenStreetMap contributors",
            maxZoom: 19,
          }).addTo(map);

          const rectangleOptions = {
            color: "#5f89ff",
            weight: 1.5,
            fillOpacity: 0.08,
          };

          scanFootprintsLayer = L.layerGroup().addTo(map);

          function boundsToObject(bounds) {
            return {
              north: bounds.getNorth(),
              south: bounds.getSouth(),
              east: bounds.getEast(),
              west: bounds.getWest(),
            };
          }

          function objectToLatLngBounds(boundsObject) {
            return L.latLngBounds(
              [
                [boundsObject.south, boundsObject.west],
                [boundsObject.north, boundsObject.east],
              ]
            );
          }

          const defaultBounds = getBoundsFromInputs();
          let currentBounds = defaultBounds
            ? boundsToObject(defaultBounds)
            : { north: 10, south: -10, east: 10, west: -10 };

          let rectangle = L.rectangle(
            objectToLatLngBounds(currentBounds),
            rectangleOptions
          ).addTo(map);

          const handleIcon = L.divIcon({
            className: "map-handle",
            iconSize: [16, 16],
            iconAnchor: [8, 8],
          });

          const handles = {
            northWest: L.marker(
              [currentBounds.north, currentBounds.west],
              { draggable: true, icon: handleIcon }
            ),
            northEast: L.marker(
              [currentBounds.north, currentBounds.east],
              { draggable: true, icon: handleIcon }
            ),
            southWest: L.marker(
              [currentBounds.south, currentBounds.west],
              { draggable: true, icon: handleIcon }
            ),
            southEast: L.marker(
              [currentBounds.south, currentBounds.east],
              { draggable: true, icon: handleIcon }
            ),
          };

          Object.values(handles).forEach((marker) => marker.addTo(map));

          function updateInputsFromBounds(boundsObject) {
            const digits = 4;
            if (boundsInputs.north) {
              boundsInputs.north.value = boundsObject.north.toFixed(digits);
            }
            if (boundsInputs.south) {
              boundsInputs.south.value = boundsObject.south.toFixed(digits);
            }
            if (boundsInputs.east) {
              boundsInputs.east.value = boundsObject.east.toFixed(digits);
            }
            if (boundsInputs.west) {
              boundsInputs.west.value = boundsObject.west.toFixed(digits);
            }
          }

          function updateHandles(boundsObject) {
            handles.northWest.setLatLng([boundsObject.north, boundsObject.west]);
            handles.northEast.setLatLng([boundsObject.north, boundsObject.east]);
            handles.southWest.setLatLng([boundsObject.south, boundsObject.west]);
            handles.southEast.setLatLng([boundsObject.south, boundsObject.east]);
          }

          function syncFromBounds(boundsObject, options = {}) {
            currentBounds = boundsObject;
            rectangle.setBounds(objectToLatLngBounds(currentBounds));
            updateHandles(currentBounds);
            if (options.updateInputs !== false) {
              updateInputsFromBounds(currentBounds);
            }
            if (options.fitMap) {
              map.fitBounds(objectToLatLngBounds(currentBounds).pad(0.05));
            }
          }

          const minLatSpan = 0.0001;
          const minLngSpan = 0.0001;

          function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
          }

          function handleDrag(corner) {
            return function () {
              const latLng = handles[corner].getLatLng();
              const updated = { ...currentBounds };
              if (corner === "northWest" || corner === "northEast") {
                updated.north = clamp(
                  latLng.lat,
                  updated.south + minLatSpan,
                  90
                );
              }
              if (corner === "southWest" || corner === "southEast") {
                updated.south = clamp(
                  latLng.lat,
                  -90,
                  updated.north - minLatSpan
                );
              }
              if (corner === "northWest" || corner === "southWest") {
                updated.west = clamp(
                  latLng.lng,
                  -180,
                  updated.east - minLngSpan
                );
              }
              if (corner === "northEast" || corner === "southEast") {
                updated.east = clamp(
                  latLng.lng,
                  updated.west + minLngSpan,
                  180
                );
              }
              syncFromBounds(updated, { fitMap: false });
            };
          }

          function handleDragEnd() {
            map.fitBounds(objectToLatLngBounds(currentBounds).pad(0.05));
          }

          handles.northWest.on("drag", handleDrag("northWest"));
          handles.northWest.on("dragend", handleDragEnd);
          handles.northEast.on("drag", handleDrag("northEast"));
          handles.northEast.on("dragend", handleDragEnd);
          handles.southWest.on("drag", handleDrag("southWest"));
          handles.southWest.on("dragend", handleDragEnd);
          handles.southEast.on("drag", handleDrag("southEast"));
          handles.southEast.on("dragend", handleDragEnd);

          refreshBoundsFromInputs = function () {
            const bounds = getBoundsFromInputs();
            if (!bounds) {
              return;
            }
            syncFromBounds(boundsToObject(bounds), { fitMap: true });
          };

          Object.values(boundsInputs).forEach((input) => {
            if (!input) return;
            input.addEventListener("change", refreshBoundsFromInputs);
            input.addEventListener("blur", refreshBoundsFromInputs);
          });

          syncFromBounds(currentBounds, { fitMap: true });
        }
      })();
    </script>

  </body>
</html>
